# 配置

> 在使用 Git 管理工程前，应该事进行一些配置工作，这可能是全局的或工程相关的。

## 忽略文件

> 工程目录下总有一些文件是不需要版本控制的，因此我们希望 Git 能自动忽略这些文件。这需要通过配置文件 .gitignore 来进行配置，该文件通常放置于工程根目录下。

.gitignore 格式规范：

* \# 注释
* 标准 glob 模式
* 以（/）开头防止递归
* 以（/）结尾指定目录
* 模式取反（!）

glob 模式， shell 所使用的简化了的正则表达式。

| *    |                          |
| ---- | ------------------------ |
| []   | \[abc\] \[0-9\]          |
| ?    |                          |
| **   | 匹配任意中间目录，a/**/z |
| !    | 取反                     |

忽略文件列表：[https://github.com/github/gitignore](https://github.com/github/gitignore)

## 必要配置

> 有一些配置很重要。
>
> 比如：用户名和邮件地址。当进行提交操作时，提交历史中会记录操作者的用户名和邮件地址。因此，我们应该将其事先配置好。

```git
git config --global user.name <USERNAME>
git config --global user.email <EMAIL>
```

> 说明：--global 选项指明该配置是全局的，但如果仅仅想当前工程使用该配置，则不要指定 --global 选项。

## 其他

```git
# 编辑器
git config --global core.editor=vim
```

# 日常使用

## 创建库

通常有两种方式，但无论如何，总需要事先创建一个远程仓库。

方法一：

```git
git clone <URL>
```

> 说明：该方法适用于全新开始建库。结果是将克隆一个“空”的库。

方法二：

```git
# 在工程根目录执行
git init
git add .
git commit -m "comment"
git remote add origin <URL>
# 场景1：远程仓库不为空
git pull --rebase origin master
# 场景2：远程仓库为空
git push -u origin master
```

> 说明：该方法适用于中途建库。基本思路是，首先创建本地仓库，然后指定远程仓库，最后将本地内容推送到远程仓库。其中可能出现两种场景，一种是远程仓库为空，另一种是不为空。前者很简单，直接推送即可；后者由于远程仓库已有内容，所以需要先拉取并变基，然后才能推送。

## 暂存区操作

### 添加到暂存区

```git
git add <.|FILES>
```

> 说明：
>
> “git add .”将把当前工作目录中所有改变加入暂存区。注意，它的影响是递归的。
>
> 对于 SVN 而言，新建的文件（未跟踪）才可以添加到索引；而对于 Git 而言，可添加到暂存区的文件不仅包括新建的未跟踪文件，还包括已修改的跟踪文件。

### 从暂存区移除

```git
git reset HEAD [FILES]
```

> 说明：
>
> 是 add 操作的逆操作。
>
> 不指定文件则清空暂存区。

### 从暂存区删除

```git
git rm [--force|-f] --cached <FILES>
```

> 说明：
>
> 简而言之，该命令的效果就是清除暂存文件，并使工作副本文件不再被跟踪。
>
> 换句话说，如果文件没有暂存，执行该命令是无效的。
>
> 文件可用 glob 模式指定，如：
>
> ```git
> git rm log/\*.log
> git rm \*~
> ```
>
> 注意，其中的“*”使用了“\”进行转义，这是因为 Git 自己处理模式，而不需要 shell 帮忙展开。
>
> 根据文件状态讨论下该命令的效果。
>
> | 当前状态 | 结果状态 | 必须 -f ？ | 文件版本 |
> | -------- | -------- | ---------- | -------- |
> | A        | ??       | N          | 工作副本 |
> | AM       | ??       | Y          | 工作副本 |
> | M        | D        | N          | 工作副本 |
> | MM       | D        | Y          | 工作副本 |
>
> 总结：
>
> 1. 不影响工作副本文件；
> 2. 对于新增文件，将还原为未跟踪状态；而修改的文件，将标记为删除。
> 3. 当暂存后又进行了修改，则需要加 -f 强制删除。因为此时，暂存的文件跟原文件和工作副本都不相同，删除可能存在内容丢失。
> 4. 命令执行后，仍可以使用 add 命令将文件重新加入暂存区。需要注意的是，已跟踪的文件重新加入暂存区后，状态是 M（右），因为它仍和原文件不同，是修改过的。

### 移动

```git
git mv <FILE_FROM> <FILE_TO>
```

> 说明：
>
> 移动或重命名。
>
> 不能操作未跟踪的文件。
>
> 等价于如下操作：
>
> ```git
> mv <FILE_FROM> <FILE_TO>
> git rm <FILE_FROM>
> git add <FILE_TO>
> ```

## 工作区操作

### 还原

```git
git checkout <FILES>
```

> 这是一个危险操作，工作副本将被覆盖。

## 查看状态

> 当需要进行 Git 操作时，通常都会先查看各文件的状态，以确定哪些文件会被处理，怎样处理。

```git 
# 默认是详细模式
# 当使用 --short 选项或其缩写 -s 时显示简览
git status [-s|--short]
```

> 说明：详细模式下会分状态列出各文件，并列出可进行的命令提示。简览模式下会每行列出一个文件，并在行首用标记标明其状态。

简览模式标记：

| 标记    | 描述               |
| :------ | ------------------ |
| ??      | 未跟踪             |
| A       | 新添加到暂存区     |
| M（左） | 被修改并放入暂存区 |
| M（右） | 被修改未放入暂存区 |

> 说明：
>
> 状态标记占2个字符的位置。从 M 标记有左右之分也可以看出来。
>
> 如果使用的是可着色的命令行，可以看出，已加入暂存区的标记是绿色的，如：A 和 M（左）；否则是红色的，如：?? 和 M（右）。
>
> MM 标记是可能的，即 M（左）和 M（右）标记不是互斥的。因此，对于 Git 而言，暂存操作不是仅仅标记文件，而是把暂存操作时的文件副本保存到了暂存区。可以想像这样的情况，某个文件被加入暂存区后，又被修改了，此时，对于这个文件而言，它的第 1 个版本被暂存了，但当前版本没有被暂存。所以其标记为 MM，即表示暂存后又被修改过。类似的 AM 也是可能的。
>
> 注意一点，有的命令选项是可以缩写的，但是完整选项是以“--”（双短线）为前缀的，而缩写是以“-”（单短线）为前缀的。

## 比较差异

```git
git diff [--cached] [<PATH>...]
```

## 查看日志

```git
git log [-p] [-n] [--stat] [--pretty=oneline|short|full|fuller] --graph
```

