

# 使用

## 标记含义

| 标记颜色 | 含义                                 |
| -------- | ------------------------------------ |
| 绿色     | 代码被执行到                         |
| 黄色     | 代码部分执行到（未完全执行所有分支） |
| 红色     | 代码没有被执行到                     |



# FAQ

## 仅类声明标红

有时，类中的代码覆盖率已经达到 100% 了，但是，类总体的覆盖率还是差一点点到 100%，而仅类声明行被标红。

> 为什么？
>
> 试想类声明是不可执行的，那还有什么没有被执行到呢？如果仔细查看对比这些类的话，会发现这些类都没有构造器。
>
> 是的，默认的的构造器没有被执行。如果我们加上无参构造器会发现类声明上的红色标记转移到无参构造器上。

添加无参构造器的测试代码即可。

> 但是，回过来说，如果一个类所有代码都覆盖到了，除了构造器，其实表示该类应该是一个工具类，那么应该创建一个私有无参构造器，以避免其实例化。

## 日志级别配置

系统中总是应该有配有日志输出的，而在一些性能要求较高的地方会使用日志框架提供的日志等级判断方法测试一下再进行日志操作，比如：

```java
if(logger.isDebugEnabled())
{
	logger.debug(xxx);
}
```

如果有这样的代码，覆盖率分析时将被标记为黄色，因为日志等级没有改变，只能测试到一条分支路径。

> 需要覆盖这部分代码吗？需要！
>
> 因为，日志记录的信息一般都不是简单的字符串，而是通过一些计算得来的，而计算中很可能出现运行时异常，这就有必要覆盖测试了。
>
> 总之，日志也是代码的一部分，需要调整日志级别来覆盖。

以 slf4j 使用 logback 为例，通常如下设置日志等级：

```java
LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
Logger logger = loggerContext.getLogger(CommandHelper.class);
logger.setLevel(Level.DEBUG);
```

