# 变量与函数

## 值类型

在 JavaScript 中，只有值有类型；变量只是这些值的容器。

* **数组**

数组是一个持有（任意类型）值的对象，这些值不是通过命名属性 / 键值索引，而是通过数字索引位置。

数组是对象，因此，a[i] 的访问方式下，当 i 可转换为整数时，访问数组元素，否则，访问属性。

稀疏数组，包含至少一个“空单元”的数组。永远不要创建和使用空单元数组。

* 其他

自行封装基本类型值，可用 Object(...) 函数（不带 new）。

不安全的 JSON 值：undefined、function、Symbol、包含循环引用的对象。

显式的类型转换，可以将任意类型转换为数字类型。

## 函数

函数是“可调用对象”，有一个内部属性 call，使其可被调用。

函数可拥有属性，其 length 属性表示其参数个数。

在整个声明中，如果function是第一个词，则是函数声明，否则是函数表达式。函数表达式可以是匿名的，而函数声明不可以省略函数名。

立即执行函数表达式（IIFE，Immediately Invoked Function Expression），常见形式有：

```javascript
// 形式一
(function(){...})();
// 形式二
(function(){...}());
```

Function prototype 本身就是一个没有操作的空函数。

## 词法作用域

作用域分为词法作用域和动态作用域，JavaScript 使用前者。

JavaScript 的词法作用域是基于编译器语义（非解释器）。

在 JavaScript 中，每个函数都有自己的作用域。作用域基本上是变量的一个集合以及如何通过名称访问这些变量的规则。只有函数内部的代码才能访问这个函数作用域中的变量。

作用域查找会在找到每一个匹配的标识符时停止。并且只会查找一级标识符（意即不会查找属性链形式访问的属性）。

可以通过eval和with欺骗词法作用域，但会导致性能下降，因为编译时将无法优化作用域查询。

非全局的变量如果被遮蔽了，将无法被访问到。

ES3+，catch分句会创建一个块作用域。

let定义循环变量时，变量在每次迭代都会声明。

## 提升

包括变量和函数在内的所有声明都会在当前作用域任何代码被执行前首先被处理，就好像声明被移动到了作用域的最开始，这称为“提升”。

只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。

函数表达式不会被提升，过早使用会引起TypeError。

函数首先被提升，然后才是变量。因此，要注意重复声明可能引发的问题。

## 闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。闭包是对作用域的引用。闭包是一个关于如何在函数作为值按需传递的词法环境中书写代码的标准。

只要使用了回调函数，实际上就是在使用闭包。

闭包是词法作用域和作为值的函数两者的直接结果之一。

> 通常，除非函数被传播到其作用域之外执行，否则即使产生了闭包也并未使用，而仅仅使用了普通的变量查询而已。

# 运算符

## 常用

### 判等

| 运算符 | 说明                       | 示例              |
| ------ | -------------------------- | ----------------- |
| ==     | 比较强制类型转换之后的结果 | 0=='0'; // true   |
| ===    | 直接比较                   | 1==='1'; // false |

> 它们性能差异是微秒级的，不必在乎。

类型转换规则：

1. \* == boolean，任何类型与布尔类型比较时，boolean => number
2. number == string，数字类型与字符串比较时，string => number

```javascript
Boolean('0'); // true
'0' == false; // true
```

> '0' == false进行了两次转换，根据规则1，等号右边的布尔值“false”转换为了数字“0”；根据规则2，等号左边的字符串“0”也转换为了数字“0”，因此相等。

### .

对于“.”而言，当其出现在数字字面量中时，优先识别为小数点，而非对象属性访问运算符。

```javascript
42.toFixed(3); // SyntaxError
(42).toFixed(3);
0.42.toFixed(3);
42..toFixed(3);
42 .toFixed(3);
```



### 类型检测

| 运算符              | 操作类型 | 结果                |
| ------------------- | -------- | ------------------- |
| typeof obj          | 基本类型 | 类型全小写字符串    |
|                     | 引用类型 | object              |
| obj instanceof Type | 基本类型 | false               |
|                     | 引用类型 | obj是否属于Type类型 |

# 表达式和语句

表达式，对一个变量或值的引用，或一组值和变量与运算符的组合。包括：

* 字面值表达式
* 变量表达式
* 算术表达式
* 赋值表达式

语句，在计算机语言中，执行特定任务的一组单词、数字和运算符。

语句，由一个或多个表达式组成。

表达式语句，一个独立的表达式。常用的表达式语句是调用表达式语句，整个语句本身就是一个函数调用表达式。



迭代，循环块的每次执行。

# 对象

## this 绑定

this 是在函数被调用时发生的绑定，指向取决于函数调用位置。

this 在任何情况下都不指向函数的词法作用域。

当一个函数被调用时，会创建一个活动记录（也称“执行上下文”），this 是记录的一个属性。

### 绑定规则

| 绑定规则 | 调用场景                | this 绑定到对象                               |
| -------- | ----------------------- | --------------------------------------------- |
| new绑定  | 由 new 调用             | 新创建对象                                    |
| 显式绑定 | 由 call/apply/bind 调用 | 指定对象                                      |
| 隐式绑定 | 由上下文对象调用        | 上下文对象                                    |
| 默认绑定 | 其他场景                | undefined（严格模式）；全局对象（非严格模式） |

隐式绑定中，对象属性引用链中只有最顶层或说最后一层会影响调用位置。

隐式丢失的情况：1. 函数别名；2. 参数传递（回调函数）；3. 回调函数修改 this。

显式绑定中，原始值当作 this 绑定对象时会装箱。

硬绑定，显式绑定的变种，定义一个包裹函数，其中使用显式绑定调用实际函数。ES5 内置硬绑定语法：Function.prototype.bind()。

JS 中 new 机制实际上和面向类的语言完全不同。

### 绑定例外

1. 将 null/undefined 作为 this 绑定对象传入 call/apply/bind，应用默认绑定。

> 为避免风险，通常传入 DMZ 对象。
>
> DMZ（demilitarized Zone，非军事区），一个空的非委托对象，通常由 Object.create(null) 创建。
>
> Object.create(null) 与 {} 很像，但不创建 Object.prototype 委托，故比 {} “更空”。

2. 间接引用，应用默认绑定。
3. 软绑定，替换默认绑定，保持其他绑定。

### 箭头函数

ES6 的箭头函数会继承外层函数调用的 this 绑定。

## 对象定义

对象定义有 2 种形式：声明（文字）形式和构造形式。

null 是基本类型。

null 和 undefined 没有构造形式，只有文字形式；Date 只有构造形式，没有文字形式。

### 属性

属性，命名的位置。

访问属性的 2 种方式：属性访问和键访问。

> 两者的区别是：“.” 操作符要求属性满足标识符命名规范，而“["..."]” 语法接受任意 UTF-8/Unicode 字符串。

属性名必是字符串，否则先被转换为字符串。

可计算属性名，ES6 特性，例：[prefix + "bar"]: "hello"。

函数永远不会“属于”一个对象。

ES6 浅拷贝，Object.assign(target, sources...)。

属性描述符，ES5 特性，包括值、可写、可枚举、可配置。Object.defineProperty(obj, prop, dest)

通常所说有的不变性都是浅不变性，而非深不变性。一些函数可以提供不同的不变性：禁止扩展（Object.preventExtensions()）、密封（Object.seal()）、冻结（Object.freeze()）……

属性存在性检查：1. in 操作符，检查对象+原型链；2. hasOwnProperty()，检查对象。

属性不一定包含值，可能是具备 getter/setter 的“访问描述符”。

for...in 循环会列举数组所有可枚举属性。

判断是否可枚举：1. obj.propertyIsEnumerable("propName")；2. Object.keys() / Object.getOwnPropertyNames()。均检查对象，暂无现成函数可同时检查原型链。

## “类”模式

JS 中，“类”是属于构造函数的。

> 对于面向类编程的语言而言，多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承就是复制。

给存在于原型链上的属性赋值的情况：

1. 属性可写， 添加新属性，屏蔽属性。
2. 属性只读，严格模式抛出错误；否则忽略。
3. 是 setter，调用 setter。

> 如果总要屏蔽属性，使用 Object.defineProperty()。

Prototype 机制，对象中的一个内部链接引用另一个对象。本质是对象之间的关联关系，即行为委托机制。

委托行为中，尽量避免在原型链不同级别中使用相同的命名，否则就需要消除引用歧义。

ES6 中，可以在任意对象的字面形式中使用简洁方法声明（concise method declaration）。因此，可避免声明中出现 function。

# 异步

## 回调

回调函数包裹或说封装了程序的延续（continuation）。

回调模式：分离回调（split-callback）、error-first 风格/Node 风格。

回调表达异步控制流程的 2 个关键缺陷：

1. 基于回调的异步不符合大脑对任务步骤的规划方式；表达异步方式的代码不易直观理解；线性理解能力的缺失
2. 由于控制反转，回调并不是可信任或可组合的；信任链完全断裂

## Promise

promise 是对“未来值”的与时间无关的封装，使得不管这个值是否已经可用，你都可以推导和组合使用它们。另外，通过一种可信任的、可组合的 promise 机制，分发回调它们也有效地解决了 IoC 信任问题。



Promise.all([]) 将会立即完成（没有完成值）， Promise.race([]) 将会永远挂起。建议，永远不要用空数组使用这些方法。

## 生成器

生成器为 JavaScript 函数引入了一种新的执行模式，其中生成器可以暂停在 yield 点上，并在之后被异步继续。暂停与继续的能力使得生成器中同步的、看似连续的代码可以在后台异步执行。通过这种方式，我们解决了回调的非线性、非局部跳转引发的代码混乱问题，因而让我们的异步代码看似同步，更容易追踪。

yield... 和 next(..) 组合起来，在生成器的执行过程中构成了一个双向消息传递系统。



生成器可以在执行当中暂停自身，可以立即恢复执行，也可以一段时间后恢复执行。

在执行当中的每次暂停 / 恢复循环都提供了一个双向信息传递的机会，生成器可以返回一个值，恢复它的控制代码也可以发回一个值。

```javascript
function *foo() { .. }
function* foo() { .. }
function * foo() { .. }
function*foo() { .. }
```

yield * .. 需要一个 iterable；然后它会调用这个 iterable 的迭代器，把自己的生成器控制委托给这个迭代器，直到其耗尽。

```javascript
function *foo() {
yield *[1,2,3];
}
```

## async & wait

async function 本质上就是生成器＋ promise ＋ run(..) 模式的语法糖。

# 正则表达式

定点主要是指在正则表达式的起点有一个虚拟的锚点，只从正则表达式的 lastIndex 属性指定的位置开始匹配。

粘性模式（sticky mode），标志位 y。

粘性匹配从 lastIndex 开始，不能自由向前移动。非定点匹配可以在匹配过程中自由向前移动。

通过使用工具 test(..) 和 match(..) ， y 定点标识带来的是一次一个的向前匹配。只是要确保每次匹配的时候 lastIndex 总是处于正确的位置上！

^ 总是指向输入起点的锚点，不被 lastIndex 影响。

y + ^ + lastIndex > 0 不兼容，总匹配失败。

多行模式 m 会改变 ^ 的含义，代表输入的起点或换行后的行首。



标志位以“gimuy”的顺序罗列，无关指定顺序。

# 模块

顶层作用域实际上是模块本身；在模块内没有全局作用域。

## 导出

```javascript
// 命名导出
export function foo() { }
export var awesome = 42;
export { bar };
// 重命名导出
export { foo as bar };
// 默认导出
// 导出函数表达式值的绑定
export default foo;
export default function foo(..) {}
// 导出标识符
export { foo as default };
// 再导出
export {foo, bar} from "baz";
export { foo as FOO, bar as BAR } from "baz";
export * from "baz";
```

除了 export default ... 形式导出一个表达式值绑定，所有其他的导出形式都是导出局部标识符的绑定。

双向绑定是不允许的。

## 导入

```javascript
import { foo, bar, baz } from "foo";
// 不是对象字面量，也不是对象解构语法，模块专用形式
// 重命名导入
import { foo as theFooFunc } from "foo";
// 默认导入
import foo from "foo";
import { default as foo } from "foo";
// 混合导入
import FOOFN, { bar, baz as BAZ } from "foo";
import foofn, * as hello from "world";
// 命名空间导入（namespace import）
import * as foo from "foo";
// 基本形式（“预加载”）
import "foo";
```

模块指定符（module specifier），因为整体目标是可静态分析的语法，模块指定符必须是字符串字面值，而不能是持有字符串值的变量。

窄导入的一个好处是使得静态分析和错误检测（比如意外使用了错误的绑定名称）更加健壮。

如果通过 * as .. 导入的模块有默认导出，它在指定的命名空间中的名字就是 default。你还可以在这个命名空间绑定之外把默认导入作为顶层标识符命名。

所有导入的绑定都是不可变和 / 或只读的。

# 类

类方法是不可枚举的，而对象方法默认是可枚举的。



class Foo vs. function Foo()：

* 由于前 ES6 可用的 Foo.call(obj) 不能工作，class Foo 的 Foo(..) 调用必须通过 new 来实现。
* function Foo 是“提升的”，而 class Foo 并不是；extends.. 语句指定了一个不能被“提升”的表达式。所以，在实例化一个 class 之前必须先声明它。
* 全局作用域中的 class Foo 创建了这个作用域的一个词法标识符 Foo，但是和 function Foo 不一样，并没有创建一个同名的全局对象属性。



static 成员在函数构造器之间的双向 / 并行链上。

# 集合

map 的本质是允许你把某些额外的信息（值）关联到一个对象（键）上，而无需把这个信息放入对象本身。

Array.from(..) 永远不会产生空槽位。

# 新特性

## 常量

const 应作为表明意图的工具，而非表达代码行为。

const 声明必须要有显式的初始化。

const 可以用在 for 、 for..in 以及 for..of 循环的变量声明中。

## 默认值

函数声明中形式参数是在它们自己的作用域中（可以把它看作是就在函数声明包裹的 ( .. ) 的作用域中），而不是在函数体作用域中。这意味着在默认值表达式中的标识符引用首先匹配到形式参数作用域，然后才会搜索外层作用域。

## 解构（destructuring）

解构，结构化赋值（structured assignment）方法。

解构的目的更多是为了声明可读性。

对于对象解构形式来说，如果省略了 var/let/const 声明符，就必须把整个赋值表达式用 ( ) 括起来。因为如果不这样做，语句左侧的 {..} 作为语句中的第一个元素就会被当作是一个块语句而不是一个对象。

解构的目的不只是为了打字更少，而是为了可读性更强。



嵌套解构可以是一种对象名称空间扁平化的简单方法。



参数的对象解构已经接近于命名参数了。

解构默认值 vs. 函数参数默认值，有时形式上看起来差不多，但其含义是不同的。

## 简洁

简洁属性，词法标识符同名的属性。



简洁方法意味着匿名函数表达式。

简洁方法应该只在不需要它们执行递归或者事件绑定 / 解绑定的时候使用。



对象字面定义属性名位置的 [ .. ] 中可以放置任意合法表达式。



super 只允许在简洁方法中出现，而不允许在普通函数表达式属性中出现。也只允许以 super.XXX 的形式（用于属性 / 方法访问）出现，而不能以 super() 的形式出现。

## 箭头函数（arrow function）

只有在函数体的表达式个数多于 1 个，或者函数体包含非表达式语句的时候才需要用 {..} 包围。如果只有一个表达式，并且省略了包围的 { .. } 的话，则意味着表达式前面有一个隐含的 return。

箭头函数总是（匿名）函数表达式，不存在箭头函数声明，没有用于事件绑定/解绑定的命名引用。

=> 与 this、arguments 和 super 的词法绑定有关。

## 遍历

迭代器（iterator）是一个结构化的模式，用于从源以一次一个的方式提取数据。

ES6 实现的是为迭代器引入一个隐式的标准化接口。

迭代器是一种有序的、连续的、基于拉取的用于消耗数据的组织方式。



JavaScript 不支持任何“接口”的概念，所以你自己的代码符合规范只是单纯的惯用法。

Iterable 接口，用来表述必需能够提供生成器的对象。



通用的惯例是，迭代器不应该在调用 return(..) 或者 thrown(..) 之后再产生任何值。



ES6 的 for..of 循环直接消耗一个符合规范的 iterable。

如果一个迭代器也是一个 iterable，那么它可以直接用于 for..of 循环。

for..in 遍历数组索引，for..of 遍历值。

可以通过为迭代器提供一个 Symbol.iterator 方法简单返回这个迭代器本身使它成为 iterable：

```javascript
var it = {
// 使迭代器it成为iterable
[Symbol.iterator]() { return this; },
next() { .. },
..
};
it[Symbol.iterator]() === it; // true
```

## Symbol

symbol 没有字面形式。

Symbol(..)不是构造器，字符串参数可选，作为用途描述。

识别 symbol 的首选方法，typeof 的输出是一个新的值（"symbol"）。

symbol 也不是 Symbol 的实例。

```javascript
sym instanceof Symbol; // false
var symObj = Object( sym );
symObj instanceof Symbol; // true
symObj.valueOf() === sym; // true
```

Symbol 本身的内部值，称为它的名称（ name ），是不在代码中出现且无法获得的。可以把这个符号值想象为一个自动生成的、（在应用内部）唯一的字符串值。

规范使用 @@ 前缀记法来指代内置符号，如：@@iterator 、 @@toStringTag 、@@toPrimitive 。



符号 @@iterator 是由 ... 展开和 for..of 循环自动使用的。

Symbol.iterator 表示任意对象上的一个专门位置（属性），语言机制自动在这个位置上寻

找一个方法，这个方法构造一个迭代器来消耗这个对象的值。很多对象定义有这个符号的

默认值。

# 定义

作用域：代码执行时的上下文，定义了变量以及函数生效的范围。

变量提升（hoisting）：在编译过程中，JS会自动把var和function声明移动到顶部的行为。

闭包：一个函数及其词法环境的组合，可在一个函数的作用范围外访问其内部的变量。

tick：事件循环的一轮。

控制反转（inversion of control），把自己程序一部分的执行控制交给某个第三方。

元编程，操作目标是程序本身的行为特性的编程。换句话说，它是对程序的编程的编程。

# 非 JavaScript

变量 document 作为一个全局变量存在。它既不是由JavaScript 引擎提供的，也不由 JavaScript 标准控制。它是一个特殊的对象，通常被称为“宿主对象”。

document 上的方法 getElementById(..) 看起来像是一个正常的 JavaScript 函数，但它其实是浏览器的 DOM 提供的指向内置方法的一个很薄的暴露接口。在某些（新版的）浏览器中，这一层可能在 JavaScript 中，但传统的 DOM 及其行为更可能是用 C/C++实现的。

alert(..) 是由浏览器提供给JavaScript 程序的，而不是由 JavaScript 引擎本身提供。你发起的调用将消息发送到浏览器内部，然后由它负责绘制并显示消息框。

console.log(..) 也是如此；你的浏览器提供了这样的机制并将其连接到开发者工具中。