# 变量与函数

## 变量类型

7种内置类型：null, undefined, boolean, number, string, object, symbol(ES6)。除了 object 以外，这几种类型都可以归类为原始类型。 

Undefined，表示尚未定义。表示未初始化变量，未提供的函数参数，对象缺少的属性的默认值，无返回值的函数的默认返回值。

Null，表示空值。可赋值给变量表示“没有值”。

Falsy类型值包括：""（空字符串）、0、null、undefined、NaN、false。

## 变量赋值

变量赋值通常分为两个阶段：1. 编译器，声明变量；2. 运行时引擎，赋值。

变量在使用时需要进行变量查询，变量查询分为LHS和RHS，其区别在于查询目的和失败行为：

|              | LHS                                                     | RHS            |
| ------------ | ------------------------------------------------------- | -------------- |
| 变量查询目的 | 赋值                                                    | 获取值         |
| 查询失败行为 | 非严格模式：自动隐式创建；<br/>严格模式：ReferenceError | ReferenceError |

严格模式禁止自动或隐式地创建全局变量。

## 函数表达式

在整个声明中，如果function是第一个词，则是函数声明，否则是函数表达式。函数表达式可以是匿名的，而函数声明不可以省略函数名。

立即执行函数表达式（IIFE，Immediately Invoked Function Expression），常见形式有：

```javascript
// 形式一
(function(){...})();
// 形式二
(function(){...}());
```

## 词法作用域

作用域分为词法作用域和动态作用域，JavaScript使用前者。

作用域，是一套规则，用于确定在何处以及如何查找标识符。

作用域查找会在找到每一个匹配的标识符时停止。并且只会查找一级标识符（意即不会查找属性链形式访问的属性）。

可以通过eval和with欺骗词法作用域，但会导致性能下降，因为编译时将无法优化作用域查询。

非全局的变量如果被遮蔽了，将无法被访问到。

ES3+，catch分句会创建一个块作用域。

let定义循环变量时，变量在每次迭代都会声明。

## 提升

包括变量和函数在内的所有声明都会在当前作用域任何代码被执行前首先被处理，就好像声明被移动到了作用域的最开始，这称为“提升”。

只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。

函数表达式不会被提升，过早使用会引起TypeError。

函数首先被提升，然后才是变量。因此，要注意重复声明可能引发的问题。

## 闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。闭包是对作用域的引用。闭包是一个关于如何在函数作为值按需传递的词法环境中书写代码的标准。

只要使用了回调函数，实际上就是在使用闭包。

> 通常，除非函数被传播到其作用域之外执行，否则即使产生了闭包也并未使用，而仅仅使用了普通的变量查询而已。

# 运算符

## 判等

| 运算符 | 说明                       | 示例              |
| ------ | -------------------------- | ----------------- |
| ==     | 比较强制类型转换之后的结果 | 0=='0'; // true   |
| ===    | 直接比较                   | 1==='1'; // false |

类型转换规则：

1. \* == boolean，任何类型与布尔类型比较时，boolean => number
2. number == string，数字类型与字符串比较时，string => number

```javascript
Boolean('0'); // true
'0' == false; // true
```

> '0' == false进行了两次转换，根据规则1，等号右边的布尔值“false”转换为了数字“0”；根据规则2，等号左边的字符串“0”也转换为了数字“0”，因此相等。

## 类型检测

| 运算符              | 操作类型 | 结果                |
| ------------------- | -------- | ------------------- |
| typeof obj          | 基本类型 | 类型全小写字符串    |
|                     | 引用类型 | object              |
| obj instanceof Type | 基本类型 | false               |
|                     | 引用类型 | obj是否属于Type类型 |

# 对象

## this 绑定

this 是在函数被调用时发生的绑定，指向取决于函数调用位置。

this 在任何情况下都不指向函数的词法作用域。

当一个函数被调用时，会创建一个活动记录（也称“执行上下文”），this 是记录的一个属性。

### 绑定规则

| 绑定规则 | 调用场景                | this 绑定到对象                               |
| -------- | ----------------------- | --------------------------------------------- |
| new绑定  | 由 new 调用             | 新创建对象                                    |
| 显式绑定 | 由 call/apply/bind 调用 | 指定对象                                      |
| 隐式绑定 | 由上下文对象调用        | 上下文对象                                    |
| 默认绑定 | 其他场景                | undefined（严格模式）；全局对象（非严格模式） |

隐式绑定中，对象属性引用链中只有最顶层或说最后一层会影响调用位置。

隐式丢失的情况：1. 函数别名；2. 参数传递（回调函数）；3. 回调函数修改 this。

显式绑定中，原始值当作 this 绑定对象时会装箱。

硬绑定，显式绑定的变种，定义一个包裹函数，其中使用显式绑定调用实际函数。ES5 内置硬绑定语法：Function.prototype.bind()。

JS 中 new 机制实际上和面向类的语言完全不同。

### 绑定例外

1. 将 null/undefined 作为 this 绑定对象传入 call/apply/bind，应用默认绑定。

> 为避免风险，通常传入 DMZ 对象。
>
> DMZ（demilitarized Zone，非军事区），一个空的非委托对象，通常由 Object.create(null) 创建。
>
> Object.create(null) 与 {} 很像，但不创建 Object.prototype 委托，故比 {} “更空”。

2. 间接引用，应用默认绑定。
3. 软绑定，替换默认绑定，保持其他绑定。

### 箭头函数

ES6 的箭头函数会继承外层函数调用的 this 绑定。

## 对象定义

对象定义有 2 种形式：声明（文字）形式和构造形式。

null 是基本类型。

null 和 undefined 没有构造形式，只有文字形式；Date 只有构造形式，没有文字形式。

### 属性

访问属性的 2 种方式：属性访问和键访问。

> 两者的区别是：“.” 操作符要求属性满足标识符命名规范，而“["..."]” 语法接受任意 UTF-8/Unicode 字符串。

属性名必是字符串，否则先被转换为字符串。

可计算属性名，ES6 特性，例：[prefix + "bar"]: "hello"。

函数永远不会“属于”一个对象。

ES6 浅拷贝，Object.assign(target, sources...)。

属性描述符，ES5 特性，包括值、可写、可枚举、可配置。Object.defineProperty(obj, prop, dest)

通常所说有的不变性都是浅不变性，而非深不变性。一些函数可以提供不同的不变性：禁止扩展（Object.preventExtensions()）、密封（Object.seal()）、冻结（Object.freeze()）……

属性存在性检查：1. in 操作符，检查对象+原型链；2. hasOwnProperty()，检查对象。

属性不一定包含值，可能是具备 getter/setter 的“访问描述符”。

for...in 循环会列举数组所有可枚举属性。

判断是否可枚举：1. obj.propertyIsEnumerable("propName")；2. Object.keys() / Object.getOwnPropertyNames()。均检查对象，暂无现成函数可同时检查原型链。

# 定义

False类型，在强制类型转换时会被转换为布尔false的值，与之相对的是“Truthy类型”。

作用域：代码执行时的上下文，定义了变量以及函数生效的范围。

变量提升（hoisting）：在编译过程中，JS会自动把var和function声明移动到顶部的行为。

闭包：一个函数及其词法环境的组合，可在一个函数的作用范围外访问其内部的变量。