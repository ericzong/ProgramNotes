# 变量与函数

## 数值类型

7种内置类型：null, undefined, boolean, number, string, object, symbol(ES6)。除了 object 以外，这几种类型都可以归类为原始类型。 

Undefined，表示尚未定义。表示未初始化变量，未提供的函数参数，对象缺少的属性的默认值，无返回值的函数的默认返回值。

表达式 void ___ 没有返回值，即 undefined。

Null，表示空值。可赋值给变量表示“没有值”。

null 是关键字，而 undefined 是标识符，即后者可当作变量来使用和赋值（严格模式不可以）。永远不要重新定义 undefined。

Falsy类型值包括：""（空字符串）、0（+0/-0）、null、undefined、NaN、false。

布尔值的封装对象由于是对象，所以恒为真。

数组是对象，因此，a[i] 的访问方式下，当 i 可转换为整数时，访问数组元素，否则，访问属性。

稀疏数组，包含至少一个“空单元”的数组。永远不要创建和使用空单元数组。

字符串不可变，指成员函数不会改变原始值，而是返回新字符串；数组成员函数在原始值上进行操作。可“借用”数组的非变更方法来处理字符串。

Symbol 并非对象，而是一种简单标量基本类型。

自行封装基本类型值，可用 Object(...) 函数（不带 new）。

不安全的 JSON 值：undefined、function、Symbol、包含循环引用的对象。

## 变量赋值

变量赋值通常分为两个阶段：1. 编译器，声明变量；2. 运行时引擎，赋值。

变量在使用时需要进行变量查询，变量查询分为LHS和RHS，其区别在于查询目的和失败行为：

|              | LHS                                                     | RHS            |
| ------------ | ------------------------------------------------------- | -------------- |
| 变量查询目的 | 赋值                                                    | 获取值         |
| 查询失败行为 | 非严格模式：自动隐式创建；<br/>严格模式：ReferenceError | ReferenceError |

严格模式禁止自动或隐式地创建全局变量。

## 函数

函数是“可调用对象”，有一个内部属性 call，使其可被调用。

函数可拥有属性，其 length 属性表示其参数个数。

在整个声明中，如果function是第一个词，则是函数声明，否则是函数表达式。函数表达式可以是匿名的，而函数声明不可以省略函数名。

立即执行函数表达式（IIFE，Immediately Invoked Function Expression），常见形式有：

```javascript
// 形式一
(function(){...})();
// 形式二
(function(){...}());
```

Function prototype 本身就是一个没有操作的空函数。

## 词法作用域

作用域分为词法作用域和动态作用域，JavaScript使用前者。

作用域，是一套规则，用于确定在何处以及如何查找标识符。

作用域查找会在找到每一个匹配的标识符时停止。并且只会查找一级标识符（意即不会查找属性链形式访问的属性）。

可以通过eval和with欺骗词法作用域，但会导致性能下降，因为编译时将无法优化作用域查询。

非全局的变量如果被遮蔽了，将无法被访问到。

ES3+，catch分句会创建一个块作用域。

let定义循环变量时，变量在每次迭代都会声明。

## 提升

包括变量和函数在内的所有声明都会在当前作用域任何代码被执行前首先被处理，就好像声明被移动到了作用域的最开始，这称为“提升”。

只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。

函数表达式不会被提升，过早使用会引起TypeError。

函数首先被提升，然后才是变量。因此，要注意重复声明可能引发的问题。

## 闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。闭包是对作用域的引用。闭包是一个关于如何在函数作为值按需传递的词法环境中书写代码的标准。

只要使用了回调函数，实际上就是在使用闭包。

> 通常，除非函数被传播到其作用域之外执行，否则即使产生了闭包也并未使用，而仅仅使用了普通的变量查询而已。

# 运算符

## 常用

### 判等

| 运算符 | 说明                       | 示例              |
| ------ | -------------------------- | ----------------- |
| ==     | 比较强制类型转换之后的结果 | 0=='0'; // true   |
| ===    | 直接比较                   | 1==='1'; // false |

> 它们性能差异是微秒级的，不必在乎。

类型转换规则：

1. \* == boolean，任何类型与布尔类型比较时，boolean => number
2. number == string，数字类型与字符串比较时，string => number

```javascript
Boolean('0'); // true
'0' == false; // true
```

> '0' == false进行了两次转换，根据规则1，等号右边的布尔值“false”转换为了数字“0”；根据规则2，等号左边的字符串“0”也转换为了数字“0”，因此相等。

### .

对于“.”而言，当其出现在数字字面量中时，优先识别为小数点，而非对象属性访问运算符。

```javascript
42.toFixed(3); // SyntaxError
(42).toFixed(3);
0.42.toFixed(3);
42..toFixed(3);
42 .toFixed(3);
```



### 类型检测

| 运算符              | 操作类型 | 结果                |
| ------------------- | -------- | ------------------- |
| typeof obj          | 基本类型 | 类型全小写字符串    |
|                     | 引用类型 | object              |
| obj instanceof Type | 基本类型 | false               |
|                     | 引用类型 | obj是否属于Type类型 |

# 对象

## this 绑定

this 是在函数被调用时发生的绑定，指向取决于函数调用位置。

this 在任何情况下都不指向函数的词法作用域。

当一个函数被调用时，会创建一个活动记录（也称“执行上下文”），this 是记录的一个属性。

### 绑定规则

| 绑定规则 | 调用场景                | this 绑定到对象                               |
| -------- | ----------------------- | --------------------------------------------- |
| new绑定  | 由 new 调用             | 新创建对象                                    |
| 显式绑定 | 由 call/apply/bind 调用 | 指定对象                                      |
| 隐式绑定 | 由上下文对象调用        | 上下文对象                                    |
| 默认绑定 | 其他场景                | undefined（严格模式）；全局对象（非严格模式） |

隐式绑定中，对象属性引用链中只有最顶层或说最后一层会影响调用位置。

隐式丢失的情况：1. 函数别名；2. 参数传递（回调函数）；3. 回调函数修改 this。

显式绑定中，原始值当作 this 绑定对象时会装箱。

硬绑定，显式绑定的变种，定义一个包裹函数，其中使用显式绑定调用实际函数。ES5 内置硬绑定语法：Function.prototype.bind()。

JS 中 new 机制实际上和面向类的语言完全不同。

### 绑定例外

1. 将 null/undefined 作为 this 绑定对象传入 call/apply/bind，应用默认绑定。

> 为避免风险，通常传入 DMZ 对象。
>
> DMZ（demilitarized Zone，非军事区），一个空的非委托对象，通常由 Object.create(null) 创建。
>
> Object.create(null) 与 {} 很像，但不创建 Object.prototype 委托，故比 {} “更空”。

2. 间接引用，应用默认绑定。
3. 软绑定，替换默认绑定，保持其他绑定。

### 箭头函数

ES6 的箭头函数会继承外层函数调用的 this 绑定。

## 对象定义

对象定义有 2 种形式：声明（文字）形式和构造形式。

null 是基本类型。

null 和 undefined 没有构造形式，只有文字形式；Date 只有构造形式，没有文字形式。

### 属性

访问属性的 2 种方式：属性访问和键访问。

> 两者的区别是：“.” 操作符要求属性满足标识符命名规范，而“["..."]” 语法接受任意 UTF-8/Unicode 字符串。

属性名必是字符串，否则先被转换为字符串。

可计算属性名，ES6 特性，例：[prefix + "bar"]: "hello"。

函数永远不会“属于”一个对象。

ES6 浅拷贝，Object.assign(target, sources...)。

属性描述符，ES5 特性，包括值、可写、可枚举、可配置。Object.defineProperty(obj, prop, dest)

通常所说有的不变性都是浅不变性，而非深不变性。一些函数可以提供不同的不变性：禁止扩展（Object.preventExtensions()）、密封（Object.seal()）、冻结（Object.freeze()）……

属性存在性检查：1. in 操作符，检查对象+原型链；2. hasOwnProperty()，检查对象。

属性不一定包含值，可能是具备 getter/setter 的“访问描述符”。

for...in 循环会列举数组所有可枚举属性。

判断是否可枚举：1. obj.propertyIsEnumerable("propName")；2. Object.keys() / Object.getOwnPropertyNames()。均检查对象，暂无现成函数可同时检查原型链。

## “类”模式

JS 中，“类”是属于构造函数的。

> 对于面向类编程的语言而言，多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承就是复制。

给存在于原型链上的属性赋值的情况：

1. 属性可写， 添加新属性，屏蔽属性。
2. 属性只读，严格模式抛出错误；否则忽略。
3. 是 setter，调用 setter。

> 如果总要屏蔽属性，使用 Object.defineProperty()。

Prototype 机制，对象中的一个内部链接引用另一个对象。本质是对象之间的关联关系，即行为委托机制。

委托行为中，尽量避免在原型链不同级别中使用相同的命名，否则就需要消除引用歧义。

ES6 中，可以在任意对象的字面形式中使用简洁方法声明（concise method declaration）。因此，可避免声明中出现 function。

# 异步

## 回调

回调函数包裹或说封装了程序的延续（continuation）。

回调方式最主要缺陷，表达异步方式的代码不易直观理解。

回调最大的问题是控制反转，它会导致信任链完全断裂。

回调模式：分离回调（split-callback）、error-first 风格/Node 风格。

回调表达异步控制流程的 2 个关键缺陷：

1. 基于回调的异步不符合大脑对任务步骤的规划方式；
2. 由于控制反转，回调并不是可信任或可组合的。

## 生成器

yield... 和 next(..) 组合起来，在生成器的执行过程中构成了一个双向消息传递系统。

# 正则表达式

粘性模式（sticky mode），标志位 y。

粘性匹配从 lastIndex 开始，不能自由向前移动。

^ 总是指向输入起点的锚点，不被 lastIndex 影响。

y + ^ + lastIndex > 0 不兼容，总匹配失败。

多行模式 m 会改变 ^ 的含义，代表输入的起点或换行后的行首。

标志位以“gimuy”的顺序罗列，无关指定顺序。

# 新特性

const 应作为表明意图的工具，而非表达代码行为。

解构的目的更多是为了声明可读性。

嵌套解构可以是一种对象名称空间扁平化的简单方法。

箭头函数总是（匿名）函数表达式，不存在箭头函数声明（arrow function）。

=> 与 this、arguments 和 super 的词法绑定有关。

for..in 遍历数组索引，for..of 遍历值。

symbol 没有字面形式。

# 定义

False类型，在强制类型转换时会被转换为布尔false的值，与之相对的是“Truthy类型”。

作用域：代码执行时的上下文，定义了变量以及函数生效的范围。

变量提升（hoisting）：在编译过程中，JS会自动把var和function声明移动到顶部的行为。

闭包：一个函数及其词法环境的组合，可在一个函数的作用范围外访问其内部的变量。

tick：事件循环的一轮。

控制反转（inversion of control），把自己程序一部分的执行控制交给某个第三方。

# 中英文对照

| 英文                          | 中文               |
| ----------------------------- | ------------------ |
| Temporal Dead Zone，TDZ       | 暂时性死区         |
| Callback hell                 | 回调地狱           |
| pyramid of doom               | 毁灭金字塔         |
| resolve                       | 决议               |
| fulfill                       | 完成               |
| reject                        | 拒绝               |
| transpiling                   | 转译               |
| shims                         | 垫片               |
| polyfills                     | 填补               |
| spread                        | 扩散 ...           |
| rest                          | 剩余               |
| interpolation                 | 插值，自动内联求值 |
| Basic Multilingual Plane，BMP | 基本多文种平面     |
| surrogate pair                | 代理对             |
| Combining Diacritical Marks   | 组合变音符号       |
| sticky mode                   | 粘性模式           |

